# syntax
$ docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARGS...]

if want to run the nginx server in detached mode
$ docker run -d -p 80:80 my_image:<tag> nginx -g 'daemon off;'

to specify which buffer to allocate {i.e. stdout, *err, *in}
$ docker run -a stdout -a stdin -it ubuntu /bin/bash

identification of containers
* UUID long identifier
* UUID short ---
* Name


to automate the PID getting process
$ docker run --cidfile="C:\Users\DipankarDas\Desktop\a" -it ubuntu:latest

in ./a there will be the pid of the container

docker process isolation is very robust
the virtual memory created has pid of 1 not even showing that of host as well 
as the other containers 
which starts at pid 1
so to use the host pid {CAUTION: should not use}
docker run --pid host .....
then run docker exec <container_id> ps -ef
we see that the host processes are also there

and similarly using --network host  	will use the host node network {no isolation}

Shared memory segments are used to accelerate inter-process communication at
memory speed, rather than through pipes or through the network stack. Shared
memory is commonly used by databases and custom-built (typically C/OpenMPI,
C++/using boost libraries) high performance applications for scientific
computing and financial services industries. If these types of applications
are broken into multiple containers, you might need to share the IPC mechanisms
of the containers, using `"shareable"` mode for the main (i.e. "donor")
container, and `"container:<donor-name-or-ID>"` for other containers.

stop the the networking
docker run --network none

Your container will use the same DNS servers as the host by default, 
but you can override this with --dns.


Example running a Redis container with Redis binding to localhost then running the redis-cli
command and connecting to the Redis server over the localhost interface.

$ docker run -d --name redis example/redis --bind 127.0.0.1
# use the redis container's network stack to access llocalhost
$ docker run --rm -it --network container:redis example/redis-cli -h 127.0.0.1


* how to setup own network and container
$ docker network create -d bridge my-net
$ docker run --network=my-net -itd --name=container3 busybox

use docker network ls
use docker ps
use docker exec container3 ls -ls

* want to add host to the container
$ docker run -it --add-host xyz:34.222.22.1 ubuntu cat /etc/hosts

The number of (attempted) restarts for a container can be obtained via docker inspect. 
For example, to get the number of restarts for container “my-container”;
$ docker inspect -f "{{ .RestartCount }}" my-container


to set the failure restart policy
$ docker run --restart=on-failure:10 redis
This will run the redis container with a restart policy of on-failure and 
a maximum restart count of 10. If the redis container 
exits with a non-zero exit status more than 10 times 
in a row Docker will abort trying to restart the container. 
Providing a maximum restart limit is only valid for the on-failure policy.

