# syntax
$ docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARGS...]

if want to run the nginx server in detached mode
$ docker run -d -p 80:80 my_image:<tag> nginx -g 'daemon off;'

to specify which buffer to allocate {i.e. stdout, *err, *in}
$ docker run -a stdout -a stdin -it ubuntu /bin/bash

identification of containers
* UUID long identifier
* UUID short ---
* Name


to automate the PID getting process
$ docker run --cidfile="C:\Users\DipankarDas\Desktop\a" -it ubuntu:latest

in ./a there will be the pid of the container

docker process isolation is very robust
the virtual memory created has pid of 1 not even showing that of host as well 
as the other containers 
which starts at pid 1
so to use the host pid {CAUTION: should not use}
docker run --pid host .....
then run docker exec <container_id> ps -ef
we see that the host processes are also there

and similarly using --network host  	will use the host node network {no isolation}

Shared memory segments are used to accelerate inter-process communication at
memory speed, rather than through pipes or through the network stack. Shared
memory is commonly used by databases and custom-built (typically C/OpenMPI,
C++/using boost libraries) high performance applications for scientific
computing and financial services industries. If these types of applications
are broken into multiple containers, you might need to share the IPC mechanisms
of the containers, using `"shareable"` mode for the main (i.e. "donor")
container, and `"container:<donor-name-or-ID>"` for other containers.

stop the the networking
docker run --network none

Your container will use the same DNS servers as the host by default, 
but you can override this with --dns.
